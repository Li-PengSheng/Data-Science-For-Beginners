<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "870a0086adbc313a8eea5489bdcb2522",
  "translation_date": "2025-08-26T20:48:28+00:00",
  "source_file": "2-Working-With-Data/05-relational-databases/README.md",
  "language_code": "th"
}
-->
# การทำงานกับข้อมูล: ฐานข้อมูลเชิงสัมพันธ์

|![ สเก็ตโน้ตโดย [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/05-RelationalData.png)|
|:---:|
| การทำงานกับข้อมูล: ฐานข้อมูลเชิงสัมพันธ์ - _สเก็ตโน้ตโดย [@nitya](https://twitter.com/nitya)_ |

คุณอาจเคยใช้สเปรดชีตในอดีตเพื่อจัดเก็บข้อมูล โดยมีชุดของแถวและคอลัมน์ ซึ่งแถวจะบรรจุข้อมูล (หรือข้อมูลที่ต้องการจัดเก็บ) และคอลัมน์จะอธิบายข้อมูลนั้น (บางครั้งเรียกว่าเมตาดาต้า) ฐานข้อมูลเชิงสัมพันธ์ถูกสร้างขึ้นบนหลักการพื้นฐานนี้ของคอลัมน์และแถวในตาราง ซึ่งช่วยให้คุณสามารถกระจายข้อมูลไปยังหลายตารางได้ สิ่งนี้ช่วยให้คุณทำงานกับข้อมูลที่ซับซ้อนมากขึ้น หลีกเลี่ยงการซ้ำซ้อน และมีความยืดหยุ่นในการสำรวจข้อมูล ลองมาสำรวจแนวคิดของฐานข้อมูลเชิงสัมพันธ์กัน

## [แบบทดสอบก่อนการบรรยาย](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/8)

## ทุกอย่างเริ่มต้นจากตาราง

ฐานข้อมูลเชิงสัมพันธ์มีตารางเป็นแกนหลัก เช่นเดียวกับสเปรดชีต ตารางคือการรวบรวมคอลัมน์และแถว โดยแถวจะบรรจุข้อมูลหรือข้อมูลที่เราต้องการทำงานด้วย เช่น ชื่อเมืองหรือปริมาณน้ำฝน และคอลัมน์จะอธิบายข้อมูลที่จัดเก็บ

เริ่มต้นการสำรวจของเราด้วยการสร้างตารางเพื่อจัดเก็บข้อมูลเกี่ยวกับเมือง เราอาจเริ่มต้นด้วยชื่อและประเทศของเมือง คุณสามารถจัดเก็บข้อมูลนี้ในตารางดังนี้:

| เมือง     | ประเทศ         |
| -------- | ------------- |
| โตเกียว  | ญี่ปุ่น         |
| แอตแลนตา | สหรัฐอเมริกา   |
| โอ๊คแลนด์ | นิวซีแลนด์     |

สังเกตชื่อคอลัมน์ **เมือง**, **ประเทศ** และ **ประชากร** ที่อธิบายข้อมูลที่จัดเก็บ และแต่ละแถวมีข้อมูลเกี่ยวกับหนึ่งเมือง

## ข้อจำกัดของการใช้ตารางเดียว

ตารางด้านบนอาจดูคุ้นเคยสำหรับคุณ ลองเพิ่มข้อมูลเพิ่มเติมในฐานข้อมูลของเรา เช่น ปริมาณน้ำฝนรายปี (หน่วยเป็นมิลลิเมตร) โดยเน้นที่ปี 2018, 2019 และ 2020 หากเราเพิ่มข้อมูลสำหรับโตเกียว อาจมีลักษณะดังนี้:

| เมือง  | ประเทศ | ปี   | ปริมาณ |
| ----- | ------- | ---- | ------ |
| โตเกียว | ญี่ปุ่น | 2020 | 1690   |
| โตเกียว | ญี่ปุ่น | 2019 | 1874   |
| โตเกียว | ญี่ปุ่น | 2018 | 1445   |

คุณสังเกตอะไรเกี่ยวกับตารางของเรา? คุณอาจสังเกตว่าเรากำลังซ้ำชื่อและประเทศของเมืองหลายครั้ง ซึ่งอาจใช้พื้นที่จัดเก็บมากและไม่จำเป็น เนื่องจากโตเกียวมีชื่อเดียวที่เราสนใจ

ลองทำสิ่งอื่น เราเพิ่มคอลัมน์ใหม่สำหรับแต่ละปี:

| เมือง     | ประเทศ         | 2018 | 2019 | 2020 |
| -------- | ------------- | ---- | ---- | ---- |
| โตเกียว  | ญี่ปุ่น         | 1445 | 1874 | 1690 |
| แอตแลนตา | สหรัฐอเมริกา   | 1779 | 1111 | 1683 |
| โอ๊คแลนด์ | นิวซีแลนด์     | 1386 | 942  | 1176 |

แม้ว่าจะหลีกเลี่ยงการซ้ำแถว แต่ก็เพิ่มความท้าทายอื่น ๆ เราจะต้องปรับโครงสร้างตารางทุกครั้งที่มีปีใหม่ นอกจากนี้ เมื่อข้อมูลของเราเพิ่มขึ้น การมีปีเป็นคอลัมน์จะทำให้การดึงข้อมูลและการคำนวณค่าซับซ้อนขึ้น

นี่คือเหตุผลที่เราต้องการหลายตารางและความสัมพันธ์ การแบ่งข้อมูลออกเป็นส่วน ๆ จะช่วยหลีกเลี่ยงการซ้ำซ้อนและมีความยืดหยุ่นมากขึ้นในการทำงานกับข้อมูล

## แนวคิดของความสัมพันธ์

กลับมาที่ข้อมูลของเราและกำหนดวิธีการแบ่งข้อมูล เรารู้ว่าเราต้องการจัดเก็บชื่อและประเทศของเมือง ดังนั้นสิ่งนี้น่าจะเหมาะสมที่สุดในตารางหนึ่ง

| เมือง     | ประเทศ         |
| -------- | ------------- |
| โตเกียว  | ญี่ปุ่น         |
| แอตแลนตา | สหรัฐอเมริกา   |
| โอ๊คแลนด์ | นิวซีแลนด์     |

แต่ก่อนที่เราจะสร้างตารางถัดไป เราต้องหาวิธีอ้างอิงแต่ละเมือง เราต้องการตัวระบุบางรูปแบบ เช่น ID หรือ (ในแง่ฐานข้อมูลทางเทคนิค) คีย์หลัก (primary key) คีย์หลักคือค่าที่ใช้ระบุแถวเฉพาะในตาราง แม้ว่าค่านี้อาจอิงตามค่าตัวเอง (เช่น เราอาจใช้ชื่อเมือง) แต่ควรเป็นตัวเลขหรือตัวระบุอื่นเสมอ เราไม่ต้องการให้ ID เปลี่ยนแปลงเพราะจะทำให้ความสัมพันธ์เสียหาย ในกรณีส่วนใหญ่ คีย์หลักหรือ ID จะเป็นตัวเลขที่สร้างขึ้นโดยอัตโนมัติ

> ✅ คีย์หลักมักถูกย่อว่า PK

### cities

| city_id | เมือง     | ประเทศ         |
| ------- | -------- | ------------- |
| 1       | โตเกียว  | ญี่ปุ่น         |
| 2       | แอตแลนตา | สหรัฐอเมริกา   |
| 3       | โอ๊คแลนด์ | นิวซีแลนด์     |

> ✅ คุณจะสังเกตว่าเราใช้คำว่า "id" และ "คีย์หลัก" สลับกันในบทเรียนนี้ แนวคิดเหล่านี้ใช้กับ DataFrames ซึ่งคุณจะสำรวจในภายหลัง DataFrames ไม่ใช้คำศัพท์ "คีย์หลัก" แต่คุณจะสังเกตว่ามันทำงานในลักษณะเดียวกัน

เมื่อเราสร้างตาราง cities แล้ว ลองจัดเก็บข้อมูลน้ำฝน แทนที่จะซ้ำข้อมูลเต็มของเมือง เราสามารถใช้ ID เราควรตรวจสอบให้แน่ใจว่าตารางที่สร้างขึ้นใหม่มีคอลัมน์ *id* ด้วย เนื่องจากทุกตารางควรมี ID หรือคีย์หลัก

### rainfall

| rainfall_id | city_id | ปี   | ปริมาณ |
| ----------- | ------- | ---- | ------ |
| 1           | 1       | 2018 | 1445   |
| 2           | 1       | 2019 | 1874   |
| 3           | 1       | 2020 | 1690   |
| 4           | 2       | 2018 | 1779   |
| 5           | 2       | 2019 | 1111   |
| 6           | 2       | 2020 | 1683   |
| 7           | 3       | 2018 | 1386   |
| 8           | 3       | 2019 | 942    |
| 9           | 3       | 2020 | 1176   |

สังเกตคอลัมน์ **city_id** ในตาราง **rainfall** ที่สร้างขึ้นใหม่ คอลัมน์นี้มีค่าที่อ้างอิงถึง ID ในตาราง **cities** ในแง่ฐานข้อมูลเชิงสัมพันธ์ทางเทคนิค สิ่งนี้เรียกว่า **foreign key**; มันคือคีย์หลักจากตารางอื่น คุณสามารถคิดว่ามันเป็นการอ้างอิงหรือพอยน์เตอร์ **city_id** 1 อ้างอิงถึงโตเกียว

> [!NOTE] foreign key มักถูกย่อว่า FK

## การดึงข้อมูล

เมื่อเราแยกข้อมูลออกเป็นสองตาราง คุณอาจสงสัยว่าเราจะดึงข้อมูลได้อย่างไร หากเราใช้ฐานข้อมูลเชิงสัมพันธ์ เช่น MySQL, SQL Server หรือ Oracle เราสามารถใช้ภาษาที่เรียกว่า Structured Query Language หรือ SQL SQL (บางครั้งออกเสียงว่า "ซีเควล") เป็นภาษามาตรฐานที่ใช้ในการดึงและแก้ไขข้อมูลในฐานข้อมูลเชิงสัมพันธ์

ในการดึงข้อมูล คุณใช้คำสั่ง `SELECT` โดยพื้นฐานแล้วคุณ **เลือก** คอลัมน์ที่คุณต้องการดู **จาก** ตารางที่มีคอลัมน์นั้น หากคุณต้องการแสดงเฉพาะชื่อเมือง คุณสามารถใช้คำสั่งต่อไปนี้:

```sql
SELECT city
FROM cities;

-- Output:
-- Tokyo
-- Atlanta
-- Auckland
```

`SELECT` คือที่ที่คุณระบุคอลัมน์ และ `FROM` คือที่ที่คุณระบุตาราง

> [NOTE] ไวยากรณ์ SQL ไม่แยกแยะตัวพิมพ์เล็กและตัวพิมพ์ใหญ่ หมายความว่า `select` และ `SELECT` มีความหมายเหมือนกัน อย่างไรก็ตาม ขึ้นอยู่กับประเภทของฐานข้อมูลที่คุณใช้งาน คอลัมน์และตารางอาจแยกแยะตัวพิมพ์เล็กและตัวพิมพ์ใหญ่ ดังนั้นจึงเป็นแนวปฏิบัติที่ดีเสมอที่จะปฏิบัติต่อทุกอย่างในโปรแกรมเหมือนกับว่ามันแยกแยะตัวพิมพ์เล็กและตัวพิมพ์ใหญ่ เมื่อเขียนคำสั่ง SQL ตามธรรมเนียมทั่วไปคือการเขียนคำสำคัญทั้งหมดด้วยตัวพิมพ์ใหญ่

คำสั่งด้านบนจะแสดงชื่อเมืองทั้งหมด ลองจินตนาการว่าเราต้องการแสดงเฉพาะเมืองในนิวซีแลนด์ เราต้องการตัวกรองบางรูปแบบ คำสำคัญ SQL สำหรับสิ่งนี้คือ `WHERE` หรือ "ที่บางสิ่งเป็นจริง"

```sql
SELECT city
FROM cities
WHERE country = 'New Zealand';

-- Output:
-- Auckland
```

## การเชื่อมโยงข้อมูล

จนถึงตอนนี้เราได้ดึงข้อมูลจากตารางเดียว ตอนนี้เราต้องการนำข้อมูลจากทั้ง **cities** และ **rainfall** มารวมกัน สิ่งนี้ทำได้โดยการ *เชื่อมโยง* ตารางเข้าด้วยกัน คุณจะสร้างการเชื่อมต่อระหว่างสองตาราง และจับคู่ค่าจากคอลัมน์จากแต่ละตาราง

ในตัวอย่างของเรา เราจะจับคู่คอลัมน์ **city_id** ใน **rainfall** กับคอลัมน์ **city_id** ใน **cities** สิ่งนี้จะจับคู่ค่าปริมาณน้ำฝนกับเมืองที่เกี่ยวข้อง ประเภทของการเชื่อมโยงที่เราจะทำคือสิ่งที่เรียกว่า *inner join* หมายความว่า หากแถวใดไม่ตรงกับแถวใดในตารางอื่น แถวเหล่านั้นจะไม่ถูกแสดง ในกรณีของเรา ทุกเมืองมีข้อมูลน้ำฝน ดังนั้นทุกแถวจะถูกแสดง

ลองดึงข้อมูลน้ำฝนสำหรับปี 2019 สำหรับทุกเมืองของเรา

เราจะทำสิ่งนี้เป็นขั้นตอน ขั้นตอนแรกคือการเชื่อมโยงข้อมูลเข้าด้วยกันโดยระบุคอลัมน์สำหรับการเชื่อมต่อ - **city_id** ตามที่เน้นไว้ก่อนหน้านี้

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
```

เราได้เน้นคอลัมน์สองคอลัมน์ที่เราต้องการ และข้อเท็จจริงที่เราต้องการเชื่อมโยงตารางเข้าด้วยกันโดยใช้ **city_id** ตอนนี้เราสามารถเพิ่มคำสั่ง `WHERE` เพื่อกรองเฉพาะปี 2019

```sql
SELECT cities.city
    rainfall.amount
FROM cities
    INNER JOIN rainfall ON cities.city_id = rainfall.city_id
WHERE rainfall.year = 2019

-- Output

-- city     | amount
-- -------- | ------
-- Tokyo    | 1874
-- Atlanta  | 1111
-- Auckland |  942
```

## สรุป

ฐานข้อมูลเชิงสัมพันธ์มุ่งเน้นไปที่การแบ่งข้อมูลระหว่างหลายตาราง ซึ่งจะถูกนำกลับมารวมกันเพื่อแสดงผลและวิเคราะห์ สิ่งนี้ให้ความยืดหยุ่นสูงในการคำนวณและจัดการข้อมูล คุณได้เห็นแนวคิดหลักของฐานข้อมูลเชิงสัมพันธ์ และวิธีการเชื่อมโยงระหว่างสองตาราง

## 🚀 ความท้าทาย

มีฐานข้อมูลเชิงสัมพันธ์มากมายบนอินเทอร์เน็ต คุณสามารถสำรวจข้อมูลโดยใช้ทักษะที่คุณได้เรียนรู้ข้างต้น

## แบบทดสอบหลังการบรรยาย

## [แบบทดสอบหลังการบรรยาย](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/9)

## ทบทวนและศึกษาด้วยตนเอง

มีแหล่งข้อมูลมากมายบน [Microsoft Learn](https://docs.microsoft.com/learn?WT.mc_id=academic-77958-bethanycheum) สำหรับคุณในการสำรวจ SQL และแนวคิดฐานข้อมูลเชิงสัมพันธ์เพิ่มเติม

- [อธิบายแนวคิดของข้อมูลเชิงสัมพันธ์](https://docs.microsoft.com//learn/modules/describe-concepts-of-relational-data?WT.mc_id=academic-77958-bethanycheum)
- [เริ่มต้นการเขียนคำสั่งด้วย Transact-SQL](https://docs.microsoft.com//learn/paths/get-started-querying-with-transact-sql?WT.mc_id=academic-77958-bethanycheum) (Transact-SQL เป็นเวอร์ชันหนึ่งของ SQL)
- [เนื้อหา SQL บน Microsoft Learn](https://docs.microsoft.com/learn/browse/?products=azure-sql-database%2Csql-server&expanded=azure&WT.mc_id=academic-77958-bethanycheum)

## งานที่ได้รับมอบหมาย

[ชื่อของงานที่ได้รับมอบหมาย](assignment.md)

---

**ข้อจำกัดความรับผิดชอบ**:  
เอกสารนี้ได้รับการแปลโดยใช้บริการแปลภาษา AI [Co-op Translator](https://github.com/Azure/co-op-translator) แม้ว่าเราจะพยายามอย่างเต็มที่เพื่อให้การแปลมีความถูกต้อง แต่โปรดทราบว่าการแปลอัตโนมัติอาจมีข้อผิดพลาดหรือความไม่แม่นยำ เอกสารต้นฉบับในภาษาต้นทางควรถือเป็นแหล่งข้อมูลที่เชื่อถือได้ สำหรับข้อมูลที่มีความสำคัญ แนะนำให้ใช้บริการแปลภาษามนุษย์ที่เป็นมืออาชีพ เราไม่รับผิดชอบต่อความเข้าใจผิดหรือการตีความที่ผิดพลาดซึ่งเกิดจากการใช้การแปลนี้