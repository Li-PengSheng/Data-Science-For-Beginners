<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "3ade580a06b5f04d57cc83a768a8fb77",
  "translation_date": "2025-08-27T08:26:17+00:00",
  "source_file": "2-Working-With-Data/08-data-preparation/README.md",
  "language_code": "ur"
}
-->
# ڈیٹا کے ساتھ کام کرنا: ڈیٹا کی تیاری

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/08-DataPreparation.png)|
|:---:|
|ڈیٹا کی تیاری - _Sketchnote by [@nitya](https://twitter.com/nitya)_ |

## [لیکچر سے پہلے کا کوئز](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/14)

ڈیٹا کے ماخذ پر منحصر ہے، خام ڈیٹا میں کچھ بے ترتیبی ہو سکتی ہے جو تجزیہ اور ماڈلنگ میں مشکلات پیدا کرے گی۔ دوسرے الفاظ میں، اس ڈیٹا کو "گندا" کہا جا سکتا ہے اور اسے صاف کرنے کی ضرورت ہوگی۔ یہ سبق ڈیٹا کو صاف کرنے اور تبدیل کرنے کی تکنیکوں پر توجہ مرکوز کرتا ہے تاکہ گمشدہ، غلط، یا نامکمل ڈیٹا کے چیلنجز سے نمٹا جا سکے۔ اس سبق میں شامل موضوعات Python اور Pandas لائبریری کا استعمال کریں گے اور [نوٹ بک میں مظاہرہ کیا جائے گا](notebook.ipynb) جو اس ڈائریکٹری میں موجود ہے۔

## ڈیٹا صاف کرنے کی اہمیت

- **استعمال اور دوبارہ استعمال میں آسانی**: جب ڈیٹا مناسب طریقے سے منظم اور نارملائز ہو تو اسے تلاش کرنا، استعمال کرنا، اور دوسروں کے ساتھ شیئر کرنا آسان ہو جاتا ہے۔

- **مطابقت**: ڈیٹا سائنس میں اکثر ایک سے زیادہ ڈیٹا سیٹس کے ساتھ کام کرنا شامل ہوتا ہے، جہاں مختلف ذرائع سے ڈیٹا سیٹس کو ایک ساتھ جوڑنے کی ضرورت ہوتی ہے۔ یہ یقینی بنانا کہ ہر انفرادی ڈیٹا سیٹ میں ایک جیسی معیاری کاری ہو، اس بات کو یقینی بنائے گا کہ جب وہ سب ایک ڈیٹا سیٹ میں ضم ہو جائیں تو ڈیٹا اب بھی کارآمد رہے۔

- **ماڈل کی درستگی**: صاف کیا گیا ڈیٹا ان ماڈلز کی درستگی کو بہتر بناتا ہے جو اس پر انحصار کرتے ہیں۔

## عام صفائی کے اہداف اور حکمت عملیاں

- **ڈیٹا سیٹ کی تلاش**: ڈیٹا کی تلاش، جو [بعد کے سبق](https://github.com/microsoft/Data-Science-For-Beginners/tree/main/4-Data-Science-Lifecycle/15-analyzing) میں شامل ہے، آپ کو وہ ڈیٹا دریافت کرنے میں مدد دے سکتی ہے جسے صاف کرنے کی ضرورت ہے۔ ڈیٹا سیٹ میں موجود اقدار کو بصری طور پر دیکھنا اس بات کی توقعات قائم کر سکتا ہے کہ باقی ڈیٹا کیسا نظر آئے گا، یا ان مسائل کا اندازہ فراہم کر سکتا ہے جنہیں حل کیا جا سکتا ہے۔ تلاش میں بنیادی سوالات، بصریات، اور سیمپلنگ شامل ہو سکتی ہے۔

- **فارمیٹنگ**: ماخذ پر منحصر ہے، ڈیٹا کی پیشکش میں بے ترتیبی ہو سکتی ہے۔ یہ ڈیٹا کی تلاش اور اس کی نمائندگی میں مسائل پیدا کر سکتا ہے، جہاں یہ ڈیٹا سیٹ میں نظر آتا ہے لیکن بصریات یا سوالات کے نتائج میں مناسب طریقے سے ظاہر نہیں ہوتا۔ عام فارمیٹنگ کے مسائل میں خالی جگہوں، تاریخوں، اور ڈیٹا کی اقسام کو حل کرنا شامل ہے۔ فارمیٹنگ کے مسائل کو حل کرنا عام طور پر ان لوگوں پر منحصر ہوتا ہے جو ڈیٹا استعمال کر رہے ہیں۔ مثال کے طور پر، تاریخوں اور نمبروں کی پیشکش کے معیارات ملک کے لحاظ سے مختلف ہو سکتے ہیں۔

- **ڈپلیکیشنز**: ایسا ڈیٹا جو ایک سے زیادہ بار موجود ہو، غلط نتائج پیدا کر سکتا ہے اور عام طور پر اسے ہٹا دینا چاہیے۔ یہ عام طور پر اس وقت ہوتا ہے جب دو یا زیادہ ڈیٹا سیٹس کو ایک ساتھ جوڑا جاتا ہے۔ تاہم، ایسے مواقع بھی ہو سکتے ہیں جہاں جوڑے گئے ڈیٹا سیٹس میں ڈپلیکیشنز ایسی معلومات فراہم کر سکتی ہیں جو محفوظ رکھنے کی ضرورت ہو۔

- **گمشدہ ڈیٹا**: گمشدہ ڈیٹا غلطیوں کے ساتھ ساتھ کمزور یا متعصب نتائج کا سبب بن سکتا ہے۔ کبھی کبھار یہ ڈیٹا کو دوبارہ لوڈ کرنے، گمشدہ اقدار کو Python جیسے کوڈ کے ذریعے بھرنے، یا صرف اس قدر اور متعلقہ ڈیٹا کو ہٹانے سے حل کیا جا سکتا ہے۔ ڈیٹا کے گم ہونے کی متعدد وجوہات ہو سکتی ہیں، اور ان گمشدہ اقدار کو حل کرنے کے لیے کیے گئے اقدامات اس بات پر منحصر ہو سکتے ہیں کہ وہ کیوں اور کیسے غائب ہوئیں۔

## ڈیٹا فریم کی معلومات کا جائزہ لینا
> **سیکھنے کا مقصد:** اس حصے کے اختتام تک، آپ pandas DataFrames میں محفوظ ڈیٹا کے بارے میں عمومی معلومات تلاش کرنے میں آرام دہ ہوں گے۔

جب آپ نے اپنا ڈیٹا pandas میں لوڈ کر لیا ہے، تو یہ زیادہ تر امکان ہے کہ یہ ایک DataFrame میں ہوگا (پچھلے [سبق](https://github.com/microsoft/Data-Science-For-Beginners/tree/main/2-Working-With-Data/07-python#dataframe) کا حوالہ دیں تفصیلی جائزہ کے لیے)۔ تاہم، اگر آپ کے DataFrame میں 60,000 قطاریں اور 400 کالم ہیں، تو آپ یہ سمجھنا کیسے شروع کریں گے کہ آپ کس کے ساتھ کام کر رہے ہیں؟ خوش قسمتی سے، [pandas](https://pandas.pydata.org/) کچھ آسان ٹولز فراہم کرتا ہے تاکہ DataFrame کے بارے میں مجموعی معلومات کو جلدی سے دیکھا جا سکے، اس کے علاوہ پہلی اور آخری چند قطاریں بھی۔

اس فعالیت کو دریافت کرنے کے لیے، ہم Python scikit-learn لائبریری کو درآمد کریں گے اور ایک مشہور ڈیٹا سیٹ استعمال کریں گے: **Iris ڈیٹا سیٹ**۔

```python
import pandas as pd
from sklearn.datasets import load_iris

iris = load_iris()
iris_df = pd.DataFrame(data=iris['data'], columns=iris['feature_names'])
```
|                                        |sepal length (cm)|sepal width (cm)|petal length (cm)|petal width (cm)|
|----------------------------------------|-----------------|----------------|-----------------|----------------|
|0                                       |5.1              |3.5             |1.4              |0.2             |
|1                                       |4.9              |3.0             |1.4              |0.2             |
|2                                       |4.7              |3.2             |1.3              |0.2             |
|3                                       |4.6              |3.1             |1.5              |0.2             |
|4                                       |5.0              |3.6             |1.4              |0.2             |

- **DataFrame.info**: شروع کرنے کے لیے، `info()` طریقہ استعمال کیا جاتا ہے تاکہ `DataFrame` میں موجود مواد کا خلاصہ پرنٹ کیا جا سکے۔ آئیے اس ڈیٹا سیٹ کو دیکھتے ہیں تاکہ معلوم ہو کہ ہمارے پاس کیا ہے:
```python
iris_df.info()
```
```
RangeIndex: 150 entries, 0 to 149
Data columns (total 4 columns):
 #   Column             Non-Null Count  Dtype  
---  ------             --------------  -----  
 0   sepal length (cm)  150 non-null    float64
 1   sepal width (cm)   150 non-null    float64
 2   petal length (cm)  150 non-null    float64
 3   petal width (cm)   150 non-null    float64
dtypes: float64(4)
memory usage: 4.8 KB
```
اس سے ہمیں معلوم ہوتا ہے کہ *Iris* ڈیٹا سیٹ میں چار کالموں میں 150 اندراجات ہیں جن میں کوئی null اندراجات نہیں ہیں۔ تمام ڈیٹا 64-bit فلوٹنگ پوائنٹ نمبروں کے طور پر محفوظ ہے۔

- **DataFrame.head()**: اگلا، `DataFrame` کے اصل مواد کو چیک کرنے کے لیے، ہم `head()` طریقہ استعمال کرتے ہیں۔ آئیے دیکھتے ہیں کہ ہمارے `iris_df` کی پہلی چند قطاریں کیسی نظر آتی ہیں:
```python
iris_df.head()
```
```
   sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
0                5.1               3.5                1.4               0.2
1                4.9               3.0                1.4               0.2
2                4.7               3.2                1.3               0.2
3                4.6               3.1                1.5               0.2
4                5.0               3.6                1.4               0.2
```
- **DataFrame.tail()**: اس کے برعکس، `DataFrame` کی آخری چند قطاروں کو چیک کرنے کے لیے، ہم `tail()` طریقہ استعمال کرتے ہیں:
```python
iris_df.tail()
```
```
     sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
145                6.7               3.0                5.2               2.3
146                6.3               2.5                5.0               1.9
147                6.5               3.0                5.2               2.0
148                6.2               3.4                5.4               2.3
149                5.9               3.0                5.1               1.8
```
> **نتیجہ:** صرف DataFrame میں موجود معلومات کے میٹا ڈیٹا یا اس میں موجود پہلی اور آخری چند اقدار کو دیکھ کر، آپ فوری طور پر اس ڈیٹا کے سائز، شکل، اور مواد کے بارے میں ایک خیال حاصل کر سکتے ہیں جس کے ساتھ آپ کام کر رہے ہیں۔

## گمشدہ ڈیٹا سے نمٹنا
> **سیکھنے کا مقصد:** اس حصے کے اختتام تک، آپ کو DataFrames سے null اقدار کو تبدیل یا ہٹانے کا طریقہ معلوم ہونا چاہیے۔

زیادہ تر وقت، وہ ڈیٹا سیٹس جو آپ استعمال کرنا چاہتے ہیں (یا استعمال کرنا پڑتے ہیں) ان میں گمشدہ اقدار ہوتی ہیں۔ گمشدہ ڈیٹا کو ہینڈل کرنے کے ساتھ ایسے نازک سمجھوتے ہوتے ہیں جو آپ کے حتمی تجزیے اور حقیقی دنیا کے نتائج کو متاثر کر سکتے ہیں۔

Pandas گمشدہ اقدار کو دو طریقوں سے ہینڈل کرتا ہے۔ پہلا آپ نے پچھلے حصوں میں دیکھا ہے: `NaN`، یا Not a Number۔ یہ دراصل ایک خاص قدر ہے جو IEEE فلوٹنگ پوائنٹ وضاحت کا حصہ ہے اور یہ صرف گمشدہ فلوٹنگ پوائنٹ اقدار کی نشاندہی کرنے کے لیے استعمال ہوتی ہے۔

فلوٹس کے علاوہ گمشدہ اقدار کے لیے، pandas Python کے `None` آبجیکٹ کا استعمال کرتا ہے۔ اگرچہ یہ الجھن پیدا کر سکتا ہے کہ آپ کو دو مختلف قسم کی اقدار کا سامنا کرنا پڑے گا جو بنیادی طور پر ایک ہی بات کہتی ہیں، لیکن اس ڈیزائن کے انتخاب کے لیے مضبوط پروگراماتی وجوہات ہیں اور عملی طور پر، اس راستے پر جانے سے pandas زیادہ تر معاملات کے لیے ایک اچھا سمجھوتہ فراہم کرتا ہے۔ اس کے باوجود، `None` اور `NaN` دونوں میں پابندیاں ہیں جن کے بارے میں آپ کو ان کے استعمال کے طریقے کے حوالے سے محتاط رہنے کی ضرورت ہے۔

`NaN` اور `None` کے بارے میں مزید جاننے کے لیے [نوٹ بک](https://github.com/microsoft/Data-Science-For-Beginners/blob/main/4-Data-Science-Lifecycle/15-analyzing/notebook.ipynb) دیکھیں!

- **null اقدار کا پتہ لگانا**: `pandas` میں، `isnull()` اور `notnull()` طریقے null ڈیٹا کا پتہ لگانے کے لیے آپ کے بنیادی طریقے ہیں۔ دونوں آپ کے ڈیٹا پر Boolean ماسک واپس کرتے ہیں۔ ہم `NaN` اقدار کے لیے `numpy` استعمال کریں گے:
```python
import numpy as np

example1 = pd.Series([0, np.nan, '', None])
example1.isnull()
```
```
0    False
1     True
2    False
3     True
dtype: bool
```
آؤٹ پٹ کو غور سے دیکھیں۔ کیا اس میں سے کچھ آپ کو حیران کرتا ہے؟ اگرچہ `0` ایک ریاضیاتی null ہے، یہ پھر بھی ایک مکمل عدد ہے اور pandas اسے اسی طرح سمجھتا ہے۔ `''` تھوڑا زیادہ پیچیدہ ہے۔ اگرچہ ہم نے اسے سیکشن 1 میں ایک خالی سٹرنگ ویلیو کی نمائندگی کے لیے استعمال کیا، یہ پھر بھی ایک سٹرنگ آبجیکٹ ہے اور pandas کے مطابق null کی نمائندگی نہیں ہے۔

اب، آئیے اس کو پلٹتے ہیں اور ان طریقوں کو اس انداز میں استعمال کرتے ہیں جیسے آپ عملی طور پر کریں گے۔ آپ Boolean ماسک کو براہ راست ایک ``Series`` یا ``DataFrame`` انڈیکس کے طور پر استعمال کر سکتے ہیں، جو گمشدہ (یا موجود) اقدار کے ساتھ کام کرنے کی کوشش کرتے وقت مفید ہو سکتا ہے۔

> **نتیجہ:** `isnull()` اور `notnull()` دونوں طریقے جب آپ انہیں `DataFrame`s میں استعمال کرتے ہیں تو اسی طرح کے نتائج پیدا کرتے ہیں: وہ نتائج اور ان نتائج کے انڈیکس دکھاتے ہیں، جو آپ کے ڈیٹا کے ساتھ کام کرتے وقت آپ کے لیے بے حد مددگار ہوں گے۔

- **null اقدار کو ہٹانا**: گمشدہ اقدار کی نشاندہی کرنے کے علاوہ، pandas `Series` اور `DataFrame`s سے null اقدار کو ہٹانے کا ایک آسان ذریعہ فراہم کرتا ہے۔ (خاص طور پر بڑے ڈیٹا سیٹس پر، تجزیے سے گمشدہ [NA] اقدار کو ہٹانا اکثر زیادہ مشورہ دیا جاتا ہے بجائے اس کے کہ انہیں دوسرے طریقوں سے ہینڈل کیا جائے۔) آئیے `example1` پر واپس آتے ہیں تاکہ یہ عمل میں دیکھیں:
```python
example1 = example1.dropna()
example1
```
```
0    0
2     
dtype: object
```
نوٹ کریں کہ یہ آپ کے آؤٹ پٹ کی طرح نظر آنا چاہیے `example3[example3.notnull()]`۔ فرق یہ ہے کہ، صرف ماسک شدہ اقدار پر انڈیکسنگ کرنے کے بجائے، `dropna` نے `Series` `example1` سے ان گمشدہ اقدار کو ہٹا دیا ہے۔

چونکہ `DataFrame`s کے دو ابعاد ہیں، وہ ڈیٹا کو ہٹانے کے لیے مزید اختیارات فراہم کرتے ہیں۔

```python
example2 = pd.DataFrame([[1,      np.nan, 7], 
                         [2,      5,      8], 
                         [np.nan, 6,      9]])
example2
```
|      | 0 | 1 | 2 |
|------|---|---|---|
|0     |1.0|NaN|7  |
|1     |2.0|5.0|8  |
|2     |NaN|6.0|9  |

(کیا آپ نے دیکھا کہ pandas نے دو کالمز کو `NaN`s کو ایڈجسٹ کرنے کے لیے فلوٹس میں اپ کاسٹ کیا؟)

آپ `DataFrame` سے ایک واحد قدر کو ہٹا نہیں سکتے، اس لیے آپ کو مکمل قطاریں یا کالمز ہٹانے ہوں گے۔ آپ جو کچھ کر رہے ہیں اس پر منحصر ہے، آپ ایک یا دوسرے کو ہٹانا چاہیں گے، اور اس لیے pandas آپ کو دونوں کے لیے اختیارات دیتا ہے۔ چونکہ ڈیٹا سائنس میں، کالمز عام طور پر متغیرات کی نمائندگی کرتے ہیں اور قطاریں مشاہدات کی نمائندگی کرتی ہیں، آپ زیادہ تر ڈیٹا کی قطاریں ہٹانے کا امکان رکھتے ہیں؛ `dropna()` کے لیے ڈیفالٹ سیٹنگ یہ ہے کہ وہ تمام قطاریں ہٹا دے جن میں کوئی null اقدار موجود ہوں:

```python
example2.dropna()
```
```
	0	1	2
1	2.0	5.0	8
```
اگر ضروری ہو، تو آپ کالمز سے NA اقدار کو ہٹا سکتے ہیں۔ ایسا کرنے کے لیے `axis=1` استعمال کریں:
```python
example2.dropna(axis='columns')
```
```
	2
0	7
1	8
2	9
```
نوٹ کریں کہ یہ بہت سا ڈیٹا ہٹا سکتا ہے جسے آپ رکھنا چاہتے ہیں، خاص طور پر چھوٹے ڈیٹا سیٹس میں۔ اگر آپ صرف ان قطاروں یا کالمز کو ہٹانا چاہتے ہیں جن میں کئی یا صرف تمام null اقدار موجود ہوں؟ آپ `dropna` میں `how` اور `thresh` پیرامیٹرز کے ساتھ ان ترتیبات کو مخصوص کر سکتے ہیں۔

ڈیفالٹ کے طور پر، `how='any'` (اگر آپ خود چیک کرنا چاہتے ہیں یا دیکھنا چاہتے ہیں کہ اس طریقے کے دوسرے پیرامیٹرز کیا ہیں، تو کوڈ سیل میں `example4.dropna?` چلائیں)۔ آپ متبادل طور پر `how='all'` مخصوص کر سکتے ہیں تاکہ صرف ان قطاروں یا کالمز کو ہٹایا جا سکے جن میں تمام null اقدار موجود ہوں۔ آئیے اپنے مثال کے `DataFrame` کو بڑھاتے ہیں تاکہ یہ عمل میں دیکھیں۔

```python
example2[3] = np.nan
example2
```
|      |0  |1  |2  |3  |
|------|---|---|---|---|
|0     |1.0|NaN|7  |NaN|
|1     |2.0|5.0|8  |NaN|
|2     |NaN|6.0|9  |NaN|

`thresh` پیرامیٹر آپ کو زیادہ باریک بینی سے کنٹرول فراہم کرتا ہے: آپ ان غیر-null اقدار کی تعداد مقرر کرتے ہیں جو کسی قطار یا کالم کو برقرار رکھنے کے لیے ضروری ہیں:
```python
example2.dropna(axis='rows', thresh=3)
```
```
	0	1	2	3
1	2.0	5.0	8	NaN
```
یہاں، پہلی اور آخری قطار کو ہٹا دیا گیا ہے، کیونکہ ان میں صرف دو غیر-null اقدار موجود ہیں۔

- **null اقدار کو بھرنا**: آپ کے ڈیٹا سیٹ پر منحصر ہے، بعض اوقات null اقدار کو درست اقدار سے بھرنا زیادہ معنی خیز ہو سکتا ہے بجائے اس کے کہ انہیں ہٹا دیا جائے۔ آپ `isnull` کو جگہ میں ایسا کرنے کے لیے استعمال کر سکتے ہیں، لیکن یہ محنت طلب ہو سکتا ہے، خاص طور پر اگر آپ کے پاس بھرنے کے لیے بہت سی اقدار ہوں۔ چونکہ یہ ڈیٹا سائنس میں ایک عام کام ہے، pandas `fillna` فراہم کرتا ہے، جو `Series` یا `DataFrame` کی ایک کاپی واپس کرتا ہے جس میں گمشدہ اقدار کو آپ کی پسند کی کسی ایک سے تبدیل کر دیا گیا ہو۔ آئیے ایک اور مثال `Series` بناتے ہیں تاکہ یہ عمل میں دیکھیں۔

```python
example3 = pd.Series([1, np.nan, 2, None, 3], index=list('abcde'))
example3
```
```
a    1.0
b    NaN
c    2.0
d    NaN
e    3.0
dtype: float64
```
آپ تمام null اندراجات کو ایک واحد قدر، جیسے `0` سے بھر سکتے ہیں:
```python
example3.fillna(0)
```
```
a    1.0
b    0.0
c    2.0
d    0.0
e    3.0
dtype: float64
```
آپ null اقدار کو **آگے بھر سکتے ہیں**، یعنی آخری درست قدر کو null کو بھرنے کے لیے استعمال کریں:
```python
example3.fillna(method='ffill')
```
```
a    1.0
b    1.0
c    2.0
d    2.0
e    3.0
dtype: float64
```
آپ null اقدار کو **پیچھے بھر سکتے ہیں** تاکہ اگلی درست قدر کو null کو بھرنے کے لیے پیچھے کی طرف پھیلایا جا سکے:
```python
example3.fillna(method='bfill')
```
```
a    1.0
b    2.0
c    2.0
d    3.0
e    3.0
dtype: float64
```
جیسا کہ آپ اندازہ لگا سکتے ہیں، یہ `DataFrame`s کے ساتھ بھی اسی طرح کام کرتا ہے، لیکن آپ null اقدار کو بھرنے کے لیے ایک `axis` بھی مخصوص کر سکتے ہیں۔ پہلے استعمال شدہ `example2` کو دوبارہ لیتے ہوئے:
```python
example2.fillna(method='ffill', axis=1)
```
```
	0	1	2	3
0	1.0	1.0	7.0	7.0
1	2.0	5.0	8.0	8.0
2	NaN	6.0	9.0	9.0
```
نوٹ کریں کہ جب آگے بھرنے کے لیے پچھلی قدر دستیاب نہ ہو، تو null قدر برقرار رہتی ہے۔
> **خلاصہ:** اپنے ڈیٹا سیٹس میں موجود گمشدہ اقدار سے نمٹنے کے کئی طریقے ہیں۔ آپ جو خاص حکمت عملی اپناتے ہیں (انہیں ہٹانا، تبدیل کرنا، یا یہاں تک کہ کس طرح تبدیل کرنا) وہ ڈیٹا کی نوعیت پر منحصر ہونا چاہیے۔ جتنا زیادہ آپ ڈیٹا سیٹس کے ساتھ کام کریں گے، اتنا ہی بہتر آپ کو گمشدہ اقدار کو سنبھالنے کا تجربہ ہوگا۔

## ڈپلیکیٹ ڈیٹا کو ہٹانا

> **سیکھنے کا مقصد:** اس حصے کے اختتام تک، آپ کو DataFrames میں ڈپلیکیٹ اقدار کی شناخت اور انہیں ہٹانے میں مہارت حاصل ہو جانی چاہیے۔

گمشدہ ڈیٹا کے علاوہ، آپ کو حقیقی دنیا کے ڈیٹا سیٹس میں اکثر ڈپلیکیٹ ڈیٹا کا سامنا ہوگا۔ خوش قسمتی سے، `pandas` ڈپلیکیٹ اندراجات کی شناخت اور انہیں ہٹانے کا ایک آسان طریقہ فراہم کرتا ہے۔

- **ڈپلیکیٹس کی شناخت: `duplicated`:** آپ pandas کے `duplicated` میتھڈ کا استعمال کرتے ہوئے آسانی سے ڈپلیکیٹ اقدار کو دیکھ سکتے ہیں، جو ایک Boolean ماسک واپس کرتا ہے جو ظاہر کرتا ہے کہ آیا `DataFrame` میں کوئی اندراج پہلے والے کا ڈپلیکیٹ ہے۔ آئیے ایک اور مثال کے طور پر `DataFrame` بناتے ہیں تاکہ اسے عملی طور پر دیکھ سکیں۔
```python
example4 = pd.DataFrame({'letters': ['A','B'] * 2 + ['B'],
                         'numbers': [1, 2, 1, 3, 3]})
example4
```
|      |letters|numbers|
|------|-------|-------|
|0     |A      |1      |
|1     |B      |2      |
|2     |A      |1      |
|3     |B      |3      |
|4     |B      |3      |

```python
example4.duplicated()
```
```
0    False
1    False
2     True
3    False
4     True
dtype: bool
```
- **ڈپلیکیٹس کو ہٹانا: `drop_duplicates`:** یہ صرف ان ڈیٹا کی ایک کاپی واپس کرتا ہے جن کے تمام `duplicated` اقدار `False` ہیں:
```python
example4.drop_duplicates()
```
```
	letters	numbers
0	A	1
1	B	2
3	B	3
```
`duplicated` اور `drop_duplicates` دونوں کا ڈیفالٹ یہ ہے کہ وہ تمام کالمز کو مدنظر رکھتے ہیں، لیکن آپ یہ وضاحت کر سکتے ہیں کہ وہ آپ کے `DataFrame` میں صرف ایک مخصوص کالمز کے سب سیٹ کا جائزہ لیں:
```python
example4.drop_duplicates(['letters'])
```
```
letters	numbers
0	A	1
1	B	2
```

> **خلاصہ:** ڈپلیکیٹ ڈیٹا کو ہٹانا تقریباً ہر ڈیٹا سائنس پروجیکٹ کا ایک لازمی حصہ ہے۔ ڈپلیکیٹ ڈیٹا آپ کے تجزیے کے نتائج کو تبدیل کر سکتا ہے اور آپ کو غلط نتائج فراہم کر سکتا ہے!

## 🚀 چیلنج

تمام زیر بحث مواد ایک [Jupyter Notebook](https://github.com/microsoft/Data-Science-For-Beginners/blob/main/2-Working-With-Data/08-data-preparation/notebook.ipynb) کی صورت میں فراہم کیا گیا ہے۔ مزید برآں، ہر سیکشن کے بعد مشقیں موجود ہیں، انہیں ضرور آزمائیں!

## [لیکچر کے بعد کا کوئز](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/15)

## جائزہ اور خود مطالعہ

ڈیٹا کو تجزیے اور ماڈلنگ کے لیے تیار کرنے کے کئی طریقے ہیں، اور ڈیٹا کی صفائی ایک اہم قدم ہے جو عملی تجربے کا تقاضا کرتا ہے۔ Kaggle کے ان چیلنجز کو آزمائیں تاکہ ان تکنیکوں کو دریافت کریں جو اس سبق میں شامل نہیں کی گئیں۔

- [ڈیٹا صفائی چیلنج: تاریخوں کو پارس کرنا](https://www.kaggle.com/rtatman/data-cleaning-challenge-parsing-dates/)

- [ڈیٹا صفائی چیلنج: ڈیٹا کو اسکیل اور نارملائز کرنا](https://www.kaggle.com/rtatman/data-cleaning-challenge-scale-and-normalize-data)

## اسائنمنٹ

[فارم سے ڈیٹا کا جائزہ لینا](assignment.md)

---

**ڈسکلیمر**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کا استعمال کرتے ہوئے ترجمہ کی گئی ہے۔ ہم درستگی کے لیے کوشش کرتے ہیں، لیکن براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا عدم درستگی ہو سکتی ہیں۔ اصل دستاویز کو اس کی اصل زبان میں مستند ذریعہ سمجھا جانا چاہیے۔ اہم معلومات کے لیے، پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کے لیے ہم ذمہ دار نہیں ہیں۔